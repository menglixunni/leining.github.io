<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********  Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>leining</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Hexo">
    <meta name="author" content="John Doe">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">雷宁</a></li>
                            <li class="nolink"><span>加油 </span>每一天.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>欢迎!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">更多</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-07-01T02:49:34.800Z" itemprop="datePublished">
          2022-07-01
      </time>
    
</span>
                <h1>vue面试题总结</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h4 id="0-echars使用步骤"><a href="#0-echars使用步骤" class="headerlink" title="0.echars使用步骤"></a>0.echars使用步骤</h4><p>1.创建一个存放图表的容器，往往使用一个div作为容器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.图表初始化,Echarts绘图时调用echarts.init() API实现图表初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(dom);</span><br></pre></td></tr></table></figure>

<p>3.设置图表配置项，传入数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    <span class="attr">xAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">yAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [&#123;</span><br><span class="line">        <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],<span class="comment">//在这里修改数据</span></span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.绘制图表。调用setOption() API实现图表绘制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (option &amp;&amp; <span class="keyword">typeof</span> option === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    myChart.<span class="title function_">setOption</span>(option, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html块级元素  div 、p、h1-h5、br———————-<br>行内元素 a、span、strong、b、img、input、select、</p>
<h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><p>flex是弹性布局，我们设置为flex的元素成为容器，容器内的其他子元素成为项目，容器默认是有两根轴，一个是水平的主轴main aixs，一个是垂直的交叉轴cross axis</p>
<p>容器的属性有flex-direction：设置项目的排列方向 row row-reserve column column-reverse</p>
<p>flex-wrap：当子元素超过父容器的长度时，是否换行，wrap nowrap wrap-reverse</p>
<p>flex-flow是flex-direction和flex-wrap的简写</p>
<p>justify-content：设置项目主轴上对齐方式，flex-start ，flex-end，center，space-between两端对齐，space-around中间是边的二倍，space-evenly间距相等</p>
<p>align-items：设置项目交叉轴的对齐方式，默认是stretch，flex-start，flex-end，center，baseline</p>
<p>align-content：当交叉轴有多余空间时，调整内容的对齐方式。</p>
<p>项目属性有order：设置显示顺序，序号越小。排在越前</p>
<p>flex-grow项目的放大比例，默认0 ，</p>
<p>flex-shrink项目的缩小比例，默认1</p>
<p>flex-basis项目的默认宽度</p>
<p>flex是flex-grow和flex-shrink和flex-basis的简写默认 0 1 auto</p>
<p>align-self可以单独设置项目的对齐方式，可覆盖align-items</p>
<h4 id="2-promise"><a href="#2-promise" class="headerlink" title="2.promise"></a>2.promise</h4><p>promise是es6新增的语法，它是解决异步编程的一种方案，他支持链式调用，可以解决回调地狱问题，promise有三种状态，padding进行中，fulfilled已成功。rejected已失败。promise对象他是一个构造函数，他的参数有两个，第一个resolve可以把padding状态改变为fulfilled，第二个reject他可以把padding改成rejected状态。promise对象的实例有三个方法，第一个是then()，他是当promise的状态改变的时候就会执行这个回调，第二个是catch()他是用来捕获错误的回调函数，第三个是finally他不管promise最后的状态如何，都会执行。promise还有all和race方法，他们都是多个promise对象组成的一个新的promise实例，all是当所有的请求都成功的时候才会返回成功，race只要有一个请求成功就会返回成功。</p>
<h4 id="3-组件间的传值"><a href="#3-组件间的传值" class="headerlink" title="3.组件间的传值"></a>3.组件间的传值</h4><p>我们常用的父子组件之间传值是props，子组件也可以向父组件传值，子组件用$emit发送，父组件用$on接受，还有常用的就是vuex和全局事件总线在任意组件之间都可以传值，还有就是插槽也可以进行传值，默认和具名插槽可以实现父组件向子组件传值，作用域插槽可以实现子组件向父组件传值。最后ref也可以通过属性传值，父组件可以改变子组件中的数据。</p>
<h4 id="4-axios"><a href="#4-axios" class="headerlink" title="4.axios"></a>4.axios</h4><p>axios的原理就是ajax，是对ajax的封装，他是基于promise实现的，符合es6语法，我们在项目中可以配置一个全局的axios，在main.js中引入axios的包，然后配置axios.defaults.baseURL,之后在vue 的原型上给他添加一个属性，vue.prototype.$http = axios，然后我们在组件中就可以使用this.$http.请求方式，然后还可以配置请求拦截器request。我们通常的用的请求方式就是get和post，我们也可以把axios封装成自己的api，方便我们以后的调用和修改。比如说就是用户没有登录的时候添加商品，当它点击他添加，先是请求拦截器就是在请求发送之前，在其请求头里给添加一个token，然后得到服务器相应之后，响应拦截器判断这个token是否有值，如果没有，那路由跳转到登录页面。</p>
<p>原生ajax，先new一个XMLHttpRequest，然后open打开请求地址和方式，然后onreadystatechange =function（），最后发送send</p>
<h4 id="5-vuex"><a href="#5-vuex" class="headerlink" title="5.vuex"></a>5.vuex</h4><p>vuex是对vue中数据集中管理的一个插件，他一共有5个属性，分别是state，用来存放数据源信息，就是一些公用的数据都要放在state中存放，在组件中使用$store.state.数据名，也可以用mapState获取，然后就是mutations，他是唯一一个可以改变store状态的一个方法，在组件中使用$store.commit来触发事件，也可以用简写方式mapMutations触发，还有就是action他的功能和mutations差不多，但是actions可以进行异步的操作，在组件中使用$store.dispatch来触发事件，或者用简写方式mapActions，还有getters属性，他就和计算属性computed差不多，就是把state中的数据加工一下，return出来，我我们直接使用加工过之后的数据，可以用$store.getters.方法名字或者mapGetters来触发，最后一个就是模块化module，就是可以把store分成若干个模块，每个模块都有state、mutations、actions、getters属性，他是为了方便我们更好的管理代码。</p>
<h4 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6.生命周期"></a>6.生命周期</h4><p>vue的生命周期可以分为8个阶段，第一个就是beforeCreate，组件实例被创建之前，这个时候是没有数据的，然后就是created，组件实例被创建，这是时候已经有了数据了，我们可以在这里去异步请求接口获取数据，然后就是beforeMount，这个是组件实例被挂载之前，虚拟的dom已经创建，但是真实的dom没有被创建，再接着就是mounted，这个时候组件实例被挂载，真实dom创建，页面也渲染出来了，我的项目中我是在mounted去异步请求获取数据，在这里还可以执行自定义事件，启动定时器等，然后就是beforeUpdate，这是被更新之前，然后就是updated这是时候数据已经被更新了，然后就是beforeDestroy，这是组件实例被销毁之前，我们在这里可以清除定时器，什么的，最后就是destroyed这个时候组件实例被销毁了。还有两个就是路由里keep-alive的两个声明周期钩子，一个是activeted，他是被keep-alive缓存的组件被激活的时候调用，另一个是deactivated，缓存的组件被停用的时候调用，还有一个就是errorCapture用来捕获异常的。</p>
<h4 id="7-computed和watch区别"><a href="#7-computed和watch区别" class="headerlink" title="7.computed和watch区别"></a>7.computed和watch区别</h4><p>computed是计算属性，他是支持缓存的。他组件被挂载的时候就会被调用一次，当数据源信息比如data里的数据还有props接受的数据被更改的时候，会再次被调用，而watch是监听属性，watch需要添加immediate才会在挂载时执行一次，他也能实现computed的功能，但是watch还可以做异步的操作，而computed只能做同步的，而且我们可以用watch做一些复杂的计算，computed适合多个数据影响一个数据，就是用在了计算购物车结算总金额的时候，watch适合一个数据影响多个数据，然后watch是用在了搜索的时候。</p>
<h4 id="8-let-const-var的区别"><a href="#8-let-const-var的区别" class="headerlink" title="8.let const var的区别"></a>8.let const var的区别</h4><p>var存在变量提升，定义之前被使用会提示undefined，let和const不存在变量提升</p>
<p>var不存在块级作用域，let和const存在</p>
<p>var不存在作用域死区，let和const存在，当他们被声明那条语句执行了，才可以被使用</p>
<p>var声明的变量可以重复声明，但是let和const不可以</p>
<p>var 和let声明的变量可以被修改，const声明的常量不可以被修改。</p>
<p>const开辟一个新的空间，</p>
<h4 id="9-数组函数"><a href="#9-数组函数" class="headerlink" title="9.数组函数"></a>9.数组函数</h4><p>shift（）、unshift（）、pop（）、push（）、reverse（）、sort（）、splice（）、</p>
<p>forEach（）、filter（）、reduce（）、findIndex（）、indexOf（）、every（）、some（）、map（）、join（）转换成字符串</p>
<h4 id="10-keep-alive"><a href="#10-keep-alive" class="headerlink" title="10.keep-alive"></a>10.keep-alive</h4><p>keep-alive是vue中内置组件，能在组件切换过程中将状态保留在内存中，防止重复传染DOM,keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，</p>
<p>keep-alive有三个属性</p>
<p>include匹配的组件会被缓存</p>
<p>exclude匹配的组件不会被缓存</p>
<p>max可以设置最多可以缓存多少实例。</p>
<p>与之对应的有两生命周期钩子，activated和deactivated，前者是当keep-alive包裹的组件被激活的时候调用，deactivated是当被keep-alive缓存的组件被停用的时候调用。</p>
<h4 id="11-v-if和v-show"><a href="#11-v-if和v-show" class="headerlink" title="11.v-if和v-show"></a>11.v-if和v-show</h4><p>v-if的切换会销毁和重新构建一个新的DOM节点，而v-show只是对DOM元素设置css样式，display：none和display：block</p>
<p>v-if只有在条件为真的时候才会加载，而v-show在初始化的时候会加载，</p>
<p>v-if在切换的时候内存消耗高，而v-show在初次加载的时候消耗高，</p>
<p>v-if适合不频繁的切换，v-show适合频繁的切换</p>
<h4 id="12-v-if和v-for"><a href="#12-v-if和v-for" class="headerlink" title="12.v-if和v-for"></a>12.v-if和v-for</h4><p>在vue2中，v-for的优先级比v-if的高，在vue3中，v-if的优先级比v-for高，不推荐一起使用，假如v-for要遍历一个1万条的数据，他会影响性能。</p>
<h4 id="13-mvvm"><a href="#13-mvvm" class="headerlink" title="13.mvvm"></a>13.mvvm</h4><p>m是model数据层，是用来存放数据的，v是view视图层， 也就是显示给用户的ui界面，然后vm就是view-model视图模型层，他是连接model和view的桥梁，mvvm是支持数据双向绑定的，首先</p>
<p>-new一个vue实例，然后compile去编译解析模板，然后初始化视图，并在watcher里绑定一个更新的函数，然后watcher在dep添加一个函数，使用observer劫持监听所有的属性，当数据变化时observer去通知dep，dep通过watcher在dep中添加的监听函数，去通知wacher有变化，然后watcher中更新函数发现watcher有变化，通知updater去更新视图。</p>
<h4 id="14-路由导航守卫"><a href="#14-路由导航守卫" class="headerlink" title="14.路由导航守卫"></a><strong>14.路由导航守卫</strong></h4><p>路由导航守卫有三种，</p>
<p>全局路由守卫</p>
<p>beforeEach在路由跳转前触发，有三个参数to、from、next，主要是用于登录验证，</p>
<p>是在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用，</p>
<p>afterEach他是在路由跳转完成后触发，参数包括to,from，他发生在beforeEach和beforeResolve之后，beforeRouteEnter之前。</p>
<p>组件内路由守卫：</p>
<p>beforeRouteEnter路由进入之前被调用，参数也是to、from、next，在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用，要注意的是该守卫内访问不到组件的实例，也就是this为undefined，也就是他在beforeCreate生命周期前触发。在这个钩子函数中，可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通过 vm访问组件实例进行赋值等操作。</p>
<p>beforeRouteUpdate在当前路由改变时，并且该组件被复用（动态路由，）时调用，可以通过this访问实例。参数包括to、from、next，还有是</p>
<p>beforeRouteLeave导航离开该组件的对应路由时调用，可以访问组件实例的this，参数包括to、from、next。</p>
<p>独享路由守卫</p>
<p>beforeEnter，<code>beforeEnter</code>和 <code>beforeEach</code> 完全相同，如果都设置则在<code>beforeEach</code>之后紧随执行，参数to、from、next</p>
<p>执行顺序：beforeRouteLeave&gt;beforeEach&gt;beforeRouteUpdate&gt;beforeEnter&gt;beforeRouteEnter&gt;beforeResolve&gt;afterEach&gt;beforeRouteEnter</p>
<h4 id="15-diff算法"><a href="#15-diff算法" class="headerlink" title="15.diff算法"></a>15.diff算法</h4><p>他是比较同层的树节点的一种高效算法，他是同层比较，从两端开始向中间靠拢，遵循的是深度优先原则，比如说旧节点abcd，新节点是abecd。旧节点和新节点相同就复用了，旧节点有的，新节点没有，直接删除，旧节点没有的，新节点有的，直接添加appendChild这个节点。</p>
<h4 id="16-路由传参"><a href="#16-路由传参" class="headerlink" title="16.路由传参"></a>16.路由传参</h4><p>有两种传参的方式，一种是query传参，通过 <code>router-link</code> 组件的 <code>to</code> 属性实现，该方法的参数可以是一个字符串路径，也可以是数组对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;Child&#x27;,query:&#123;id:123&#125;&#125;&quot;</span>&gt;进入<span class="title class_">Child</span>路由&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/Child&#x27;</span></span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: m.<span class="property">id</span>,</span><br><span class="line">         <span class="attr">title</span>: m.<span class="property">title</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span></span><br></pre></td></tr></table></figure>

<p>另一种是<code>params</code> 传参,使用params传参时，to用的是对象的写法，必须使用name配置项，to也可以是字符串就得是路径了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;Child&#x27;,params:&#123;id:123&#125;&#125;&quot;</span>&gt;进入<span class="title class_">Child</span>路由&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">    	<span class="attr">id</span>:<span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span></span><br></pre></td></tr></table></figure>

<h4 id="17-v-model"><a href="#17-v-model" class="headerlink" title="17.v-model"></a>17.v-model</h4><p>1.在input标签里，绑定v-bind用来记录值，然后就是再添加@input，让绑定的v-bind值等于e.target.value</p>
<p>2.在select标签里，绑定v-bind用来记录值，然后就是再添加@change事件，让绑定的v-bind的值等于e.target.value</p>
<h4 id="18-插槽"><a href="#18-插槽" class="headerlink" title="18.插槽"></a>18.插槽</h4><p>插槽就是子组件中的提供给父组件使用的一个占位符，用slot表示，父组件可以在这个占位符中填充任意代码，然后该内容会将子组件的slot给替换掉。</p>
<p>第一个是默认插槽，他就是子组件里的slot没有设置name，而父组件的内容也没有设置，他会默认把父组件没有设置名字的内容给替换到子组件没有设置name的slot组件中。</p>
<p>第二个是具名插槽，就是给插槽起了个名字 就是在slot 中添加一个name=名字，可以放在不同的地方，然后父组件通过v-slot：名字将指定父组件替换到子组件对应名字的slot，v-slot要和template一起搭配才可以使用。</p>
<p>第三个就是作用域插槽，通过插槽可以传数据，可以用来子组件向父组件传值，子组件中在slot里把数据名字写上，父组件里通过scope=子组件的数据名字，来接受子组件传过来的数据。子组件只用来传数据，父组件用来显示子组件的内容想要展示的样式。</p>
<h4 id="19-动态添加类"><a href="#19-动态添加类" class="headerlink" title="19.动态添加类"></a>19.动态添加类</h4><p>class他有一个参数，可以是三种类型，第一种写法是字符串 当名字不确定时，需要动态修改，第二种写法是对象，当要绑定的样式，个数不确定，名字也不确定时，第三种是数组写法，要绑定多个样式，个数确定，名字也确定，但是不确定使不使用的时候。</p>
<p>style的用法和class一样，传值可以是数组也可以是对象。</p>
<h4 id="20-0-1-0-2-0-3"><a href="#20-0-1-0-2-0-3" class="headerlink" title="20.  0.1+0.2 == 0.3"></a>20.  0.1+0.2 == 0.3</h4><p>0.1加0.2是不等于0.3的， 我们进行任何加法运算的时候，首先都会转换成二进制进行计算，而0.1和0.2转换成二进制，会出现循环，当他们相加的时候，会截取一段进行相加，从而会导致截取后面的部分数据丢失，使得计算结果小于0.3</p>
<h4 id="21-如何判断一个数据是否一个数组类型"><a href="#21-如何判断一个数据是否一个数组类型" class="headerlink" title="21.如何判断一个数据是否一个数组类型"></a>21.如何判断一个数据是否一个数组类型</h4><p>首先，判断一个数据属于什么类型，typeof没法判断数据，数组是一个特殊的对象，所以我们用instanceof方法，去判断他的类型，然后也可由通过它的原型去判断是否为数组，ta的constructor 是否等于数组类型。或者是它的–proto–是否等于数组的原型prototype</p>
<h4 id="22-原型和原型链"><a href="#22-原型和原型链" class="headerlink" title="22.原型和原型链"></a>22.原型和原型链</h4><p>js的每个函数对象在创建的时候，都会生成一个prototype属性，这个属性指向一个对象，这个对象就是此函数的原型。该原型对象中有个属性为constructor，指向该函数。然后通过构造函数创建出来的实例对象，其本身都有一个属性叫 __ proto __   这个属性会指向该实例对象的构造函数的原型对象，原型对象他是一个对象他也有 __ proto 属性，最终会指向object的原型对象，然后object的原型对象的custructor指向的是object，object的prototype属性又指向obejcet的原型对象，这样就形成了一个类似链条的关系，我们把这个就叫做原型链。</p>
<p>​    function hanshu(){</p>
<p>​    }</p>
<p>​    let a = new hanshu()</p>
<p>​    hanshu().prototype = 函数的原型对象</p>
<p>​    hanshu() = hanshu().prototype.constructor 函数的原型对象的constructor</p>
<p>​    a._ <em>proto</em>_ = hanshu().prototype</p>
<h4 id="23-es6-class"><a href="#23-es6-class" class="headerlink" title="23.es6 class"></a>23.es6 class</h4><p>class是构造函数的另一种写法，他必须有constructor构造方法，用来做初始化的操作，也可以用get和set关键字，对某个属性设置存值函数和取值函数。在class中的方法前可以加一个static，使该方法变为静态方法，他不会被继承，可以通过类来直接调用。我们生成的类也需要通过new去实例化一个对象，class之间可以通过extends去继承别的类，子类必须要用super方法去调用继承父类的方法，</p>
<h4 id="24-es6-的-set，map"><a href="#24-es6-的-set，map" class="headerlink" title="24.es6 的 set，map"></a>24.es6 的 set，map</h4><p>es6中的set和数组类似，set不可以有重复的元素，所以可以做去重操作，set本身就是一个构造函数，我们可以使用new set去创建一个set集合，可以通过add方式向set集合中添加元素。set还有size方法，用来返回长度，has方法，判断集合内是否存在某个内容，返回的是布尔值，还有delete方法，删除集合内某个元素，返回的也是布尔值，最后一个clear方法，直接清空集合内容。我们可以使用。keys，values和forEach方法遍历set集合。</p>
<p>array.from可以把类数组变成数组</p>
<p>map用于存储映射关系，之前我们一直是使用对象来存储映射关系的，之前我们是一直使用对象来存储映射关系的，map的键和值都可以是任意类型的，map本身也是一构造函数，也可以通过new map去实例化，他的实例有size属性，可以显示map的成员总数，还有set方法，可以设置键名和对应的值，如果键名重复，则更新键值，最后返回整个map结构，get方法用来获取键名对应的值，如果找不到则返回undefined，has方法，用来判断某个键是否在map中，返回一个布尔值，还有delete方法，删除某个键，返回的也是布尔值，最后一个就是clear，清除map的所有成员，map可以用keys和forEach遍历。</p>
<h4 id="25-解构赋值"><a href="#25-解构赋值" class="headerlink" title="25.解构赋值"></a>25.解构赋值</h4><p>es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这样就称为结构赋值，</p>
<p>数组的结构赋值，当解构不成功时，变量的值就等于undefined，解构赋值时允许给变量设置默认值，也是引用解构赋值的其他变量，但是该变量必须是已经声明的，不然就会报错。</p>
<p>然后对象的解构赋值与数组不同的是，数组是按顺序排列的，变量的取值由它的位置决定，而对象的属性没有顺序。变量必须与属行同名，才可以取到正确的值，字符串，函数参数也可以解构赋值。</p>
<h4 id="26-animation和transition的区别"><a href="#26-animation和transition的区别" class="headerlink" title="26.animation和transition的区别"></a>26.animation和transition的区别</h4><p>1、transition 需要去触发比如：点击事件、鼠标移入事件；而 animation 可以配合 @keyframe 可以不触发事件就触发这个动画</p>
<p>2、transition 触发一次播放一次；而 animation 则是可以设置很多的属性，比如循环次数，动画结束的状态等等；</p>
<p>3、transition关注的是样式属性的变化，属性值和时间的关系是一个三次贝塞尔曲线；而animation作用于元素本身而不是样式属性，可以使用关键帧的概念，可以实现更自由的动画效果；</p>
<p>4、在性能方面：浏览器有一个主线程和排版线程；主线程一般是对 js 运行的、页面布局、生成位图等等，然后把生成好的位图传递给排版线程，而排版线程会通过 GPU 将位图绘制到页面上，也会向主线程请求位图等等；我们在用使用 aniamtion 的时候这样就可以改变很多属性，像我们改变了 width、height、postion 等等这些改变文档流的属性的时候就会引起，页面的回流和重绘，对性能影响就比较大，但是我们用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等不会生成新的位图，当然也就不会引起页面的重排了。</p>
<h4 id="27-动画-transform、transition、animation"><a href="#27-动画-transform、transition、animation" class="headerlink" title="27.动画 transform、transition、animation"></a>27.动画 transform、transition、animation</h4><p>transform</p>
<p>做过轮播图，和钟表，</p>
<h4 id="28-响应式"><a href="#28-响应式" class="headerlink" title="28.响应式"></a>28.响应式</h4><p>响应式页面的设计与开发应当根据用户行为以及设备屏幕不同大小，进行相应的响应和调整。他的原理就是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有<code>meta</code>声明<code>viewport</code></p>
<ul>
<li><p>width=device-width: 是自适应手机屏幕的尺寸宽度</p>
</li>
<li><p>maximum-scale:是缩放比例的最大值</p>
</li>
<li><p>inital-scale:是缩放的初始化</p>
</li>
<li><p>user-scalable:是用户的可以缩放的操作</p>
<p>实现响应式布局的方式有如下：媒体查询、百分比、vw/vh、rem</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//head里配置</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">//css里设置</span></span></span><br><span class="line"><span class="string"><span class="tag">@media screen and (max-width: 1920px)&#123;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="29-闭包"><a href="#29-闭包" class="headerlink" title="29.闭包"></a>29.闭包</h4><p>闭包可以简单理解成：定义在一个函数内部的函数。由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之被收回，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数—也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后，作用域内的值也不会被销毁。</p>
<p>闭包就是定义在函数内部的一个函数，也就是函数内部嵌套函数。函数内部可以引用外部的参数和变量。然后就是参数和变量不会被回收。使用闭包可以避免全局变量的污染；缺点就是会使变量长期驻扎在内存中；会造成内存泄露。应用在 Ajax 请求的成功回调，事件绑定的回调方法， setTimeout 的延时回调。</p>
<h4 id="30-防抖和节流"><a href="#30-防抖和节流" class="headerlink" title="30.防抖和节流"></a>30.防抖和节流</h4><p>防抖和节流本质上是优化高频率执行代码的一种手段，有的事件会一直触发，会导致资源浪费，性能降低。所以采用防抖和节流 的方式来减少调用频率。节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效。防抖: n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时。防抖关注一定时间连续触发的事件，在一段连续操作结束后，处理回调。而节流，在一段连续操作中，每一段时间只执行一次。</p>
<h4 id="31-深浅拷贝"><a href="#31-深浅拷贝" class="headerlink" title="31.深浅拷贝"></a>31.深浅拷贝</h4><p>浅拷贝和深拷贝在拷贝时都会创建一个新的对象</p>
<p>浅拷贝时，只会拷贝第一层，如果是基本类型，直接拷贝值，如果是引用类型，则拷贝内存地址。如果对象里有引用类型，修改新对象，原对象也会被修改。</p>
<p>深拷贝时，会开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址。修改新对象，不会影响原对象。</p>
<p>浅拷贝直接用一个for循环遍历一次就可以实现，深拷贝则需要用到递归才能实现。</p>
<p>浅拷贝的方法有：<code>Object.assign、concat、lodash.clone</code></p>
<p>深拷贝方法有：<code>jQuery.extend()、JSON.stringify()、lodash.cloneDeep()</code> </p>
<p>json.stringify的缺陷会忽略undefined和symbol和函数</p>
<h4 id="33-js数据类型"><a href="#33-js数据类型" class="headerlink" title="33.js数据类型"></a>33.js数据类型</h4><p>基本数据类型：number、string、boolean、undefined、null、symbol，</p>
<p>引用数据类型：array、object、function</p>
<h4 id="34-隐式转换"><a href="#34-隐式转换" class="headerlink" title="34.隐式转换"></a>34.隐式转换</h4><p>js中的隐式转换分为两种，一个是数学运算符中的转换，一个是逻辑语句中的转换，我们在对各种不是number类型的使用数学运算符时（- * /)时，会先将非Number类型转换为Number类型。</p>
<p>然后加法的时候，分三种情况，</p>
<p>一侧是字符串时，会被当做字符串拼接，先把另一侧转为字符串类型。</p>
<p>一侧是number类型，另一侧是基本类型时，则将原、基本类型转换为number类型，</p>
<p>一侧是number类型，另一侧是引用类型时，将引用类型和number类型转换成字符串后拼接。</p>
<p>然后就是当字符串和数字、布尔值比较时都会转换为数字，再比较。</p>
<p>当对象和布尔值、字符串、数字比较时，对象都先转换为字符串，除字符串其他都要转为数字，再比较。</p>
<h4 id="35-跨域"><a href="#35-跨域" class="headerlink" title="35.跨域"></a>35.跨域</h4><p>指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。</p>
<p>同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</p>
<p>document.domin解决无法读取非同源网页的cookie问题，（此方案仅限主域相同，子域不同的跨域应用场景。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个页面都设置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;test.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还可以使用window.postMessage()，它可用于解决以下方面的问题：页面和其打开的新窗口的数据传递，多窗口之间消息传递，页面与嵌套的iframe消息传递，上面三个场景的跨域数据传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> openWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://test2.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span></span><br><span class="line">openWindow.<span class="title function_">postMessage</span>(<span class="string">&#x27;Nice to meet you!&#x27;</span>, <span class="string">&#x27;http://test2.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>3.JSONP，它是服务器与客户端跨源通信的常用方法，</p>
<p>原生js，通过script标签使用src，把请求地址写到这里面</p>
<p>使用jquery 通过ajax发请求，url放请求地址，type请求类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vue中</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">jsonp</span>(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">jsonp</span>: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4.CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</p>
<p>1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin</p>
<p>2、带cookie跨域请求：前后端都需要进行设置<br>5.vue中使用proxy配置代理，解决跨域问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">target</span>: <span class="string">&quot;http://192.168.25.20:8088&quot;</span> <span class="comment">// 后端接口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有就是websocket和nginx反向代理也可以解决跨域问题</p>
<h4 id="36-自定义指令"><a href="#36-自定义指令" class="headerlink" title="36.自定义指令"></a>36.自定义指令</h4><p>自定义指令可以通过Vue.directive方法进行全局注册，它有两个参数，第一个是指令的名字，第二参数是对象数据，也可以是一个指令函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册通过在组件<code>options</code>选项中设置<code>directive</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在模板中使用v-指令名字就可以使用了，</p>
<p>自定义指令常用的钩子函数有，</p>
<p>bind只调用一次，指令与元素成功绑定时调用。</p>
<p>inserted：指令所在元素被插入页面时调用。</p>
<p>update：指令所在模板结构被重新解析时调用。</p>
<p>自定义指令用在判断用户权限，比如说一个数据，管理员可以看到删除按钮，而用户只能看到这条数据。</p>
<h4 id="37-minxs"><a href="#37-minxs" class="headerlink" title="37.minxs"></a>37.minxs</h4><p>对于一些在多个页面都会用到的方法和功能可以写在mixns中，之后每次用到只需引入mixin文件到用到的页面即可实现复用。<br>mixin文件的定义与正常vue组件的定义完全一致，都有 created,mounted…等钩子函数，以及data,methods方法用来声明当前用到的数据和方法。minix会在引入文件 中进行 属性和方法的合并（混入）minxs优先执行，相同字段名首先会覆盖。相同函数名会合并为一个数组会优先执行minix。</p>
<h4 id="38-深度监听"><a href="#38-深度监听" class="headerlink" title="38.深度监听"></a>38.深度监听</h4><p>watch里的deep属性改为true，开启深度监听</p>
<h4 id="39-修改element-ui默认样式，"><a href="#39-修改element-ui默认样式，" class="headerlink" title="39.修改element-ui默认样式，"></a>39.修改element-ui默认样式，</h4><p>组件库中标签名字，就是class属性的名字，我们直接在style里重新给这个标签设置css属性值就可以改变默认样式，有的时候可能需要加上！important。’deep‘</p>
<h4 id="40-封装echarts"><a href="#40-封装echarts" class="headerlink" title="40.封装echarts"></a>40.封装echarts</h4><p>选择器权重， id&gt;类=伪类&gt;标签&gt;伪元素</p>
<h4 id="41-json和map的区别"><a href="#41-json和map的区别" class="headerlink" title="41.json和map的区别"></a>41.json和map的区别</h4><p>map里边的键值可以使任意，json必须是字符串。</p>
<h4 id="42-call-apply-bind"><a href="#42-call-apply-bind" class="headerlink" title="42.call apply bind"></a>42.call apply bind</h4><p>call、apply、bind作用是改变函数的this指向，</p>
<p>apply接受两个参数，第一个参数是this参数是函数接受的参数，以数组的形式传入改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次，当第一个参数为null、undefined的时候，默认指向window。</p>
<p>call方法的第一个参数也是this的指向，后面传入的是一个参数列表。跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次。当第一个参数为null、undefined的时候，默认指向window。</p>
<p>bind方法和call相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)。改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</p>
<h4 id="43-JavaScript垃圾回收机制"><a href="#43-JavaScript垃圾回收机制" class="headerlink" title="43.JavaScript垃圾回收机制"></a>43.JavaScript垃圾回收机制</h4><h5 id="1-标记清除："><a href="#1-标记清除：" class="headerlink" title="1.标记清除："></a>1.标记清除：</h5><p>原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
<p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。去掉环境中的变量以及被环境中的变量引用的变量的标记。<br>再被加上标记的会被视为准备删除的变量。垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p>
<h5 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2.引用计数"></a>2.引用计数</h5><p>原理：跟踪记录每个值被引用的次数。</p>
<p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。<br>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。<br>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1。<br>当引用次数变成0时，说明没办法访问这个值了。<br>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</p>
<h4 id="44-Script标签中defer和anysc属性的区别"><a href="#44-Script标签中defer和anysc属性的区别" class="headerlink" title="44.Script标签中defer和anysc属性的区别"></a>44.Script标签中defer和anysc属性的区别</h4><p>defer 是不会阻塞html解析的，它是等DOM加载完之后再去执行JavaScript代码；async是JavaScript下载完成，就会立即执行代码，等待执行完之后才继续解析HTML。</p>
<p>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。</p>
<h4 id="45-宏任务与微任务"><a href="#45-宏任务与微任务" class="headerlink" title="45.宏任务与微任务"></a>45.宏任务与微任务</h4><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>
<p>常见的微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="#宏任务"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/JavaScript/event_loop.html#%E5%AE%8F%E4%BB%BB%E5%8A%A1">#</a>宏任务</h5><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>
<p>常见的宏任务有：</p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout/setInterval</li>
<li>UI rendering/UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I/O（Node.js）</li>
</ul>
<h4 id="46-阻止冒泡事件有三种方法："><a href="#46-阻止冒泡事件有三种方法：" class="headerlink" title="46.阻止冒泡事件有三种方法："></a>46.阻止冒泡事件有三种方法：</h4><p>1.event.stopPropagation()方法<br>    $(‘.btn’).click(function (even) {<br>        even.stopPropagation();<br>        alert(‘按钮被点击了’);<br>    })<br>这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开。<br>例如：<br>2.event.preventDefault()方法<br>    $(‘.btn’).click(function (even) {<br>        even.preventDefault();<br>        alert(‘按钮被点击了’);<br>    })<br>这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；</p>
<p>3.return false ；<br>    $(‘.btn’).click(function (even) {<br>        alert(‘按钮被点击了’);<br>        return false;<br>    })<br>这个方法比较暴力，他会同事阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()</p>
<h4 id="47-返回url"><a href="#47-返回url" class="headerlink" title="47.返回url"></a>47.返回url</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		<span class="keyword">var</span> url;	</span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>; <span class="comment">/* 获取完整URL */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http://127.0.0.1:8020/Test/index.html#test?name=test */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>; <span class="comment">/* 获取文件路径（文件地址） */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* /Test/index.html */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>; <span class="comment">/* 获取协议 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>; <span class="comment">/* 获取主机地址和端口号 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http://127.0.0.1:8020/ */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>; <span class="comment">/* 获取主机地址 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http://127.0.0.1/ */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">port</span>; <span class="comment">/* 获取端口号 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* 8020 */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>; <span class="comment">/* 获取锚点（“#”后面的分段） */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* #test?name=test */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>; <span class="comment">/* 获取属性（“?”后面的分段） */</span></span><br><span class="line">	<span class="title function_">alert</span>(url);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果需要URL中的某一部分，可以自己进行处理 */</span></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>;</span><br><span class="line">	url = url.<span class="title function_">substring</span>(url.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>, url.<span class="property">length</span>);</span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* /index.html */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 如果页面使用了框架（frameset）</span></span><br><span class="line"><span class="comment">	 * 要获取到指定页面的URL</span></span><br><span class="line"><span class="comment">	 * 只要把window换成指定的页面即可</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* &#x27;frame&#x27;为指定页面的class名 */</span></span><br><span class="line">	<span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">frames</span>[<span class="string">&#x27;frame&#x27;</span>].<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">	<span class="comment">/* 获取当前地址栏中显示的URL */</span></span><br><span class="line">	<span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">	<span class="comment">/* window parent 可互换 */</span></span><br><span class="line">	<span class="keyword">var</span> url = parent.<span class="property">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    
    <a class="pull-right" href="/2022/06/30/hello-world/">
        Hello World →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By John Doe. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
